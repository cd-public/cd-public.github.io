---
title: C89/99
theme: dark
author: Prof. Calvin
subtitle: "Week 0x1"
institute: Crypto
format: 
    revealjs: 
        theme: dark
        mainfont: monospace
execute:
  echo: false
---

# Announcements

- **Welcome** to variously CS 276/CS 540
- **Action Items**:
  - Get out our feelings on the Enigma assignment
    - We are learning by doing.
  - Next homework coming out now - Ch/Maj

# Homework

- The first homework, "Enigma", is due when class starts Th of Week 0x1
- The next homework, "Ch/Maj", is ready at any time
  - Fiddling with bits, building on the lab, etc.
  - Applies our learnings from today.
  
# Today

- Reintroduce the technologies
  - `podman`
  - `vim`
  - `gcc`
  - `git`
  
# What is Podman?

- **Definition:**
  - Platform to develop, ship, and run applications in isolated containers.
- **Benefits:**
  - Portability, consistency across environments.
- **Editorializing:**
  - Probably all code should be written in a container now that they exist.

# In practice:

- **Windows** only
  - Run `wsl --install -d ubuntu` command once
- **Windows+Mac:**
  - Use Podman Installer once
  - Launch Podman Desktop each time you code
  - Use `podman` commands
- **Linux:**
  - Have fun with your package manager.


# Podman

- Podman solves the problem of writing code on one computer and running it another.
- Simply specify a Podman image
  - a description of a imaginary computer
- Podman will pretend to be that computer
- We can run code "inside" Podman
  - Code in the container can't tell it's running inside Podman

# Images

- Something we `podman run -it` is an _image_
  - It is a template that corresponds to many possible pretend computers
  - I think of them like object oriented class
  - They define something that could be

# Containers

- Each time we run said command, we have a different _container_
  - They have different file systems
  - Things we install don't persist to future `run` instances.
  - I think of them like objects of a class
  - Like '1' instead of 'integer'
  - They are actually existing, running code.

# Reuse

- On Enigma, probably:
  - You opened a container.
  - You wrote some code in vim.
  - You compiled the code.
  - You ran the executable.
  - The executable deorbited a space station. /s
  - You closed the container and went to touch grass.

# Attach

- After touching grass, you
  - Came back to your PC
  - Had no graceful way to continue working on the code you wrote.
- We solve this with attachment and detachment.

# Servers

- One of the most common ways to use containers is web dev.
- They are easier to think of as:
  - A program, which
  - Hosts a webpage, which
  - Happens to need to run somewhere
    - That somewhere is a command line
    - Inside a pretend computer (container).
    
# Sample

- Docker maintains a sample container.
  - Podman is busy being free and open source.
- Try this:
```email
podman run -d -p 8080:80 docker/welcome-to-docker
```
- You can probably find it at this link:
  - [http://127.0.0.1:8080/](http://127.0.0.1:8080/)

# Breakdown

| Command    | Explanation |
| -------- | ------- |
| `podman`  | do something with containers   |
| `run` | run a new container     |
| `-d`    | detach - we'll cover this next    |
| `-p`  | This is port forward... |
| `8080:80` | 80 is where websites usually live
|           | 8080 is where we went (:8080)
| `docker/...` | Name of an image |

# Ports

- Ports aren't the point, but
- We should demystify.
- Change `8080:80` to `8083:80`
```email
podman run -d -p 8083:80 docker/welcome-to-docker
```
- Change the link as well.
  - [http://127.0.0.1:8083/](http://127.0.0.1:8083/)
  
# Two pages

- Wait a minute...
  - There's a webpage at 8080
  - There's a webpage at 8083
  - They're both from the same image.
  - They were started in the same command line (maybe)
- That is two containers running concurrently.
  - Enter `-d`
  
# Detach

- When we run an image with the `-d` flag, it:
  - Created and run as any other container, but
  - Runs "in the background"
    - Control does not change to container
    - It runs only its start command
    - It's just like a remote web server.

# Detach Dev

- A perhaps nicer way to write code is
  - Create and detach a container
  - Leave it running or whatever
  - Use other `podman` commands to:
    - Pop into the container and e.g. `vim`
    - Transfer files in our out
    - Pause and restart to save resources.


# ps

- When fiddling about with containers...
  - It's good to know who they are (names)
  - And what they do (command)
- We can use `podman ps`
```email
podman ps
```
- We see two servers (nginx) running 
  
```email
CONTAINER ID  IMAGE                                      COMMAND               CREATED        STATUS        PORTS                         NAMES
7d6af09131b5  docker.io/docker/welcome-to-docker:latest  nginx -g daemon o...  2 minutes ago  Up 2 minutes  0.0.0.0:8080->80/tcp, 80/tcp  confident_darwin
2e1b9f844dcd  docker.io/docker/welcome-to-docker:latest  nginx -g daemon o...  2 minutes ago  Up 2 minutes  0.0.0.0:8083->80/tcp, 80/tcp  adoring_shamir
```

# ps -a

- You have probably also made many containers
- `podman ps -a` to see old containers.
```email
podman ps -a
```
- I had many such containers!
  - 4 GB worth, to be exact
- Clean them all up with prune
```email
podman system prune
```
- System = containers, images, everything

# exec -it

- If there's a detached container running
- We can execute commands in that container.
- You only have to specify enough of the name or id to be unique.
  - I had a server at 8080 beginning with id 7...
```email
podman exec -it 7d echo hello
```
- This returns hello, directly, without switching into the container.

# /bin/sh

- So far, I haven't found a container without `/bin/sh`
- This is the Linux command line, more or less
  - bash > sh, but sometimes only sh available
- We can get an interactive command prompt via
```email
podman exec -it 7d /bin/sh
```
- This is roughly the same as `run -it`
  - But on an existing container, not a base image
  
# vim

- I've adopted a strong preference for just using `vim`
  - When I exit `vim`, I implicitly exit the container.
  - Feels better than typing `exit`, to me
- So if we create an image with vim, we can
```email
podman exec -it ð˜ªð˜®ð˜¢ð˜¨ð˜¦_ð˜¯ð˜¢ð˜®ð˜¦ vim
```
- And go from there.

# Today

- Reintroduce the technologies
  - &check; `podman`
  - `vim`
  - `gcc`
  - `git`

# IDEs

- At some point in time, code started being written in IDEs.
  - Integrated design environments.
  - To me, the first one was Eclipse (for Java)
- VS Code is the ascendent IDE, and is everywhere.
  - Google Cloud has **browser based** VS Code clone
- VS Code has some nice things - including good `git` and `docker` (less so `podman`) integration.
  
  
# Integration

- VS Code has some nice things 
  - Works with `git`/`docker` (less so `podman`).
  - You know what else can do that?
  - The command line
  - Which you don't have to install
- IDEs are ~new, the was command line utilities
  - Vi(m)
  - Emacs
  - Nano
  
# Why Vim?

- While IDEs are ascendent...
  - The are not installed on every system
  - They can be hard to use in cloud
  - They can start costing money at any time
  - They seem slower and to produce worse code
- Like Python, IDEs are easy!
  - This is good for new coders
  - It is a design decision thereafter
  
# Vim

- Vim isn't too bad
  - It can basically be used as a keyboard navigated text editor.
  - It has really good keyboard shortcuts and modes that we learn over time.
  - It seems to be the pound-for-pound productivity champion of all time.
- It is hard to find people who have learned `vim` who don't prefer it.

# Podvim

- We can install and run `vim` inside a container (which happens to run Debian & &there4; `apt`)
- Even directly from Python...
```py
>>> import os
>>> os.system("apt update") # update the registry of packages
<blah blah blah>
>>> os.system("apt install vim -y") # -y saves us from having to say "yes" to any prompts
<blah blah blah>
>>> os.system("vim") # a vim window will open
```
- This is `vim` inside `python` inside `podman`
  - Don't do this, it's a proof-of-concept

# Vim
- It looks like this:
```bash
~               VIM - Vi IMproved
~                  version 9.1
~            by Bram Moolenaar et al.
~   Vim is open source and freely distributable
~
~          Become a registered Vim user!
~  type  :help register<Enter>   for information
~
~  type  :q<Enter>              to exit
~  type  :help<Enter>  or  <F1> for on-line help
~  type  :help version9<Enter>  for version info
```

# Usage

- I usually use vim as `vim filename.py`
  - When `vim` opens I type `i` (for "insert")
  - Then I write code.
  - ESC &rarr; `:x` &rarr; ENTER to save+quit
- Learn `vim` incrementally by using it for this class - for code, for notes, for whatever.


# Today

- &check; Introduce the course
  - &check; The C Programming Language
  - &check; Cryptography + Cryptocurrency
- Introduce the technologies
  - &check; `podman`
  - &check; `vim`
  - `gcc`
  - `git`

# GCC

- Developed for the C language to make an open source operating system in 1987.
- Mainly around today for the C language to make an open source operating system (Linux)
- (The C language was invented to write an operating system).
- `python` is written in GCC C
```python
C:\Users\cd-desk>podman run -it python
Python 3.13.1 (main, Dec  4 2024, 20:40:27) [GCC 12.2.0] on linux
```

# Great freeware

- Many legendary programs created using GCC:
  - HTTPD & NGINX, which serve a majority of webtraffic
  - Every major Linux and FreeBSD distribution
  - Major browsers like Firefox and Chromium
    - Firefox is on `clang` now but that's new
  - GNU Bash and Coreutils, like `cat`, `ls`, `rm`
  - Bitcoin Core
  
# Compilation

- Like `python` or `podman` or `vim`, GCC is a command - `gcc`
- `gcc` takes at least one argument: a filename, usually of a C file
- GCC takes this C file and makes an executable 
  - a program, sort of
- Executables run as command with `./` prefix
  - This differs from `python` which runs a script **without** creating a corresponding program.

# .py vs .c

```{mermaid}
%%| theme: Darkly
flowchart LR
  A(Python) --> B[fname.py file]
  B --> C[python fname.py]
  C --> D{hello world}
  E(C) --> F[fname.c  file]
  F --> G[gcc fname.c -o ename]
  G --> H[./ename]
  H --> I{hello world}
```

- _You only have to compile once to have the executable forever._
- _Most programs are executables, not scripts._

# Today

- &check; Introduce the course
  - &check; The C Programming Language
  - &check; Cryptography + Cryptocurrency
- Introduce the technologies
  - &check; `podman`
  - &check; `vim`
  - &check; `gcc`
  - `git`
  
# Git

<ul>
<li> Git was invented... to store the C language source code for an open source operating system (Linux)</li>
<li> It is de facto the only way in the universe to store code other than "on my HDD/SSD"</li>
<li> It is also a very good way to
    <ul>
    <ol>
    <li> Keep track of podman images</li>
    <li> Keep track of podman containers</li>
    <li> Keep track of code used inside containers</li>
    </ol>
    </ul>
</li>

# As a command

- Git corresponds, like the others, to a command: `git`
  - It is common now to use other techniques, but the command remains extremely **stable**
- Quoth GitHub, the first and greatest of the collaboration tools:

<a href="https://docs.github.com/en/get-started/using-github/connecting-to-github"><blockquote>
If you want a lot of control and flexibility, you can use the command line.
</blockquote></a>