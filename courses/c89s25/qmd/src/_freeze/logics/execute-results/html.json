{
  "hash": "bb7b2e44855b339932ad4433df51c7ab",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Logics\ntheme: dark\nauthor: Prof. Calvin\nsubtitle: \"Week 0x8 II\"\ninstitute: Crypto\nformat: \n    revealjs: \n        code-fold: true\n        theme: dark\n        mainfont: monospace\n        slide-number: true\n        show-slide-number: all\n        width: 1050\n        height: 700\n        footer: \"[Home](../index.html)\"\n\nexecute:\n    echo: true\n    cache: true\n    freeze: true  # never re-render during project render\n    code-fold: false\n---\n\n\n# Announcements\n\n- Last Lecture\n    - Security topics unrelated to crypto\n    - Some automata theory\n- Action items\n    - `heap_t` due now\n    - `BTCinC` final is out\n\n\n# Today\n\n- Threat and Threat Models\n- (Trace) Properties\n- Kripke Structures\n- Linear Temporal Logic\n- Büchi Automata\n    - DFAs\n    - Safety & Liveness\n- CIA Triad\n\n\n# Threat\n\n- \"Security\" is incomplete as a concept.\n\n    *   **What** is secure?\n    *   **For whom** is the 'what' secure?\n    *   **From whom** is the 'what' secure?\n\n# Bitcoin\n\n*   **Bitcoins** are secure.\n*   **For all senders and receivers** the ownership is secured.\n*   **From any third party** the doublespending is secured.\n\n# Limitations\n\n*   Can a third party tell **who** uses the service?\n*   Can a third party tell **when** coins are being sent?\n*   Can a third party tell the **amount** of the transaction?\n\n# Models\n\nUse **threat modeling**:\n\n*   Description of the subject to be modeled\n*   Assumptions that can be checked or challenged\n*   Potential threats to the system\n*   Actions that can be taken to mitigate each threat\n*   A way of validating the model and threats\n\nRead more: [OWASP.org](https://owasp.org/www-community/Threat_Modeling)\n\n\n# \n\n|Informally|Formally|\n|-|-|\n|**What?**|Description of the subject to be modeled|\n|**For whom?**|A way of validating the model and threats|\n|**From whom?**|Potential threats to the system|\n|**Any limitations?**|Assumptions that can be checked|\n|**How?**|Actions that can be taken to mitigate each threat|\n\n# BTC\n\n|Informally|Formally|\n|-|-|\n|**What?**|Currency|\n|**For whom?**|An economy with internet access|\n|**From whom?**|Fraud, central authority, surveillance|\n|**Any limitations?**|Public ledger|\n|**How?**|[bchain.html](bchain.html)|\n\n\n# How?\n\nWe can instead proceed in **four steps**.\n\n1.   **Diagram:** What are we building?\n1.   **Identify threats:** What could go wrong?\n1.   **Mitigate:** What are we doing to defend against threats?\n1.   **Validate:** Have we acted on each of the previous steps?\n\n\n# Diagram\n\n<a style=\"filter:invert(1)\" title=\"Graingert, CC0, via Wikimedia Commons\" href=\"https://commons.wikimedia.org/wiki/File:Bitcoin_Transaction_Visual.svg\"><img width=\"80%\" alt=\"The mine is closed and the key must stop working.  And this key structure has stopped already.  by the reason for moving the blueprint and will use the code to confirm the AI ​​service to verify the person instead  and generate income into the new...\" src=\"https://upload.wikimedia.org/wikipedia/commons/c/ce/Bitcoin_Transaction_Visual.svg\"></a>\n\n# Threats\n\n- What if?\n    - Two entities have the same private key?\n    - Dishonest nodes have more compute power?\n    - Internet goes down?\n\n# Mitigate\n\n- Well...\n    - Keys are ~4096 bit...\n    - There are other more lucrative uses of compute than competing with BTC nodes\n    - If the internet goes down, coins can't be spent but persist locally\n\n# Validate\n\n- This is new!\n- Cryptobook uses \"Attack Games\"\n- We explore \"digital signature\"\n\n# [Cryptobook](https://toc.cryptobook.us/book.pdf):\n\n> We give\nthe adversary the power to mount a **chosen message attack**, namely the attacker can request the\nsignature on any message of his choice. Even with such power, the adversary should not be able\nto create an **existential forgery**, namely the attacker cannot output a valid message-signature\npair $(m, \\omega)$ for some new message $m$. \n\n# [Cryptobook](https://toc.cryptobook.us/book.pdf):\n\n**Attack Game 13.1 (Signature security).** For a given signature scheme $\\mathcal{S} = (\\mathcal{G}, \\mathcal{S}, \\mathcal{V})$, (generate, sign, verify) defined over $(\\mathcal{M}, \\Sigma)$, (messages, signatures), and a given adversary $\\mathcal{A}$, the attack game runs as follows:\n\n* The challenger runs $(pk, sk) \\leftarrow \\mathcal{G}()$ (private signing key, public verifying key) and sends $pk$ to $\\mathcal{A}$.\n\n# [Cryptobook](https://toc.cryptobook.us/book.pdf):\n\n**Attack Game 13.1 (Signature security).** For a given signature scheme $\\mathcal{S} = (\\mathcal{G}, \\mathcal{S}, \\mathcal{V})$, (generate, sign, verify) defined over $(\\mathcal{M}, \\Sigma)$, (messages, signatures), and a given adversary $\\mathcal{A}$, the attack game runs as follows:\n\n* $\\mathcal{A}$ queries the challenger several times. For $i = 1, 2, \\dots$, the $i^{th}$ signing query is a message $m_i \\in \\mathcal{M}$. Given $m_i$, the challenger computes $\\sigma_i \\leftarrow \\mathcal{S}(sk, m_i)$, and then gives $\\sigma_i$ to $\\mathcal{A}$.\n\n\n# [Cryptobook](https://toc.cryptobook.us/book.pdf):\n\n**Attack Game 13.1 (Signature security).** For a given signature scheme $\\mathcal{S} = (\\mathcal{G}, \\mathcal{S}, \\mathcal{V})$, (generate, sign, verify) defined over $(\\mathcal{M}, \\Sigma)$, (messages, signatures), and a given adversary $\\mathcal{A}$, the attack game runs as follows:\n\n* Eventually $\\mathcal{A}$ outputs a candidate forgery pair $(m, \\sigma) \\in \\mathcal{M} \\times \\Sigma$.\n\n# [Cryptobook](https://toc.cryptobook.us/book.pdf):\n\n**Attack Game 13.1 (Signature security).** For a given signature scheme $\\mathcal{S} = (\\mathcal{G}, \\mathcal{S}, \\mathcal{V})$, (generate, sign, verify) defined over $(\\mathcal{M}, \\Sigma)$, (messages, signatures), and a given adversary $\\mathcal{A}$, the attack game runs as follows:\n\n* We say that the adversary wins the game if the following two conditions hold:\n\n$$\n\\mathcal{V}(pk, m, \\sigma) = \\text{accept}\n$$\n\n# Techniques\n\n*   **Define the scope** and depth of analysis.\n*   Gain a **visual understanding** of what you’re threat modeling.\n*   Visually **model** the attack possibilities.\n*   **Identify** threats.\n*   **Document** of missing or weak security controls.\n\n# Scope\n\n*   Determine **stakeholders**\n    *   Who uses the service?\n    *   Who provides the service?\n    *   Who benefits from the service?\n    *   Who does not benefit from the service?\n\n# Scope\n\n*   Who can answer these questions?\n    *   Are they the same or different people?\n    *   Should you do this by yourself?\n    *   What do you do if you need help?\n\n# Visuals\n\n```{dot}\n//| fig-width: 1000px\n//| output-location: slide\ndigraph block_chain {\n  rankdir=TD;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n      shape=record\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  1 [label=\"{h(prev)|<here> h(root)}|{time|nonce}\"]\n  0 [label=\"{<there> h(prev)|<here> h(root)}|{time|nonce}\"]\n  2 [label=\"{<there> h(prev)|<here> h(root)}|{time|nonce}\"]\n  merkle [label=\"{<1> 0x1|h(*0x2,*0x3)}|{0x2|h(*0x4,*0x5)}|{0x3|h(*0x6,*0x7)}|{0x4|h(*0x8,*0x9)}|{0x5|h(*0xA,*0xB)}|{0x6|<6> h(G,C,2)}|{0x7|<7> h(A,G,4)}|{0x8|<8> h(A,B,1)}|{0x9|<9> h(B,C,2)}|{0xA|<A> h(C,D,3)}|{0xB|<B> h(F,A,7)}\"]\n  \n  heap [shape=record, label=\"{send|recv|amnt}|{<e> G|C|2}|{<f> A|G|4}|{<a> A|B|1}|{<b> B|C|2}|{<c> C|D|3}|{<d> F|A|7}\"]\n\n  1 -> 0:there\n  0 -> merkle:1\n  0 -> 2:there\n  merkle:7 -> heap:f\n  merkle:6 -> heap:e\n  merkle:B -> heap:d\n  merkle:A -> heap:c\n  merkle:9 -> heap:b\n  merkle:8 -> heap:a\n\n}\n```\n\n\n\n# Threats\n\n*   What if?\n    - Someone changes `(G,C,2)` to `(G,C,3)`\n    - `G` submits a second `(G,G,2)` next block\n    - `G` loses their private key?\n\n# Document\n\n- [https://bitcoin.org/bitcoin.pdf](https://bitcoin.org/bitcoin.pdf)\n- [https://github.com/bitcoin/bitcoin](https://github.com/bitcoin/bitcoin)\n\n# **Traffic light**\n\n*   **Diagram:** What are we building?\n*   **Identify threats:** What could go wrong?\n*   **Mitigate:** What are we doing to defend against threats?\n*   **Validate:** Have we acted on each of the previous steps?\n\n# Today\n\n- &check; Threat and Threat Models\n- (Trace) Properties\n- Kripke Structures\n- Linear Temporal Logic\n- Büchi Automata\n    - DFAs\n    - Safety & Liveness\n- CIA Triad\n\n# Properties\n\n*   An **security policy** may have **properties**.\n*   These **security policies** are distinct from the **what?** of a threat model\n*   Rather the **security policy** is the **how?** of a threat model\n\nA security policy could have the property of being **secure** if the threats of a threat model are mitigated\n\n# Trace Properties\n\n*   I think of properties in terms of **traces**\n*   A **trace** is the sequence of states through which a system passes over time.\n    *   A **sequence** is an ordered collection.\n    *   A **state** is the configuration of a system at some specific time point.\n    *   A **system** implements the security policy.\n    *   Emphasize the notion of **over time**. Traces are **time-based**.\n\n# Traffic Light\n\n*   Think of a **traffic light**.\n    *   In what **states** may a traffic light be?\n    *   In what **sequence** may these states occur?\n    *   Does a traffic light implement a **security policy**\n    *   Do traffic lights **change over time**?\n\n# State Machine\n\n- A traffic light is a **state machine**.\n\n> [A **state machine** is a mathematical model of computation. It is an abstract machine that can be in exactly one of a finite number of states at any given time.](https://en.wikipedia.org/wiki/Finite-state_machine)\n\n- Often called \"FSM\" (finite state machine)\n    - I don't have a hot new start-up selling infinite states.\n\n# A Trace\n\n- We can denote the state of a traffic light by the lit color. (\"Wow this class is lit.\")\n- A trace may appear as:\n\n::: {#61341892 .cell 0='c' 1='o' 2='d' 3='e' 4='-' 5='f' 6='o' 7='l' 8='d' 9=':' 10='f' 11='a' 12='l' 13='s' 14='e' execution_count=1}\n``` {.python .cell-code}\ntrace = [\n    \"RED___\",\n    \"GREEN_\",\n    \"YELLOW\",\n    \"RED___\",\n    \"GREEN_\",\n    \"YELLOW\",\n    \"RED___\",\n    \"GREEN_\",\n    \"YELLOW\"\n]\n```\n:::\n\n\n# Examples\n\n- Let's review some traces and see if they are from a traffic light system that is operating properly.\n\n::: {#8be39ebf .cell execution_count=2}\n``` {.python .cell-code}\nsummarize = lambda t : \"\".join([s[0] for s in t])\nsumm = summarize(trace)\nprint(summ)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRGYRGYRGY\n```\n:::\n:::\n\n\nStart\n-----\n\nDoes **starting state** matter?\n\n    trace = [\n        \"YELLOW\",\n        \"RED___\",\n        \"GREEN_\",\n        \"YELLOW\",\n        \"RED___\",\n        \"GREEN_\",\n        \"YELLOW\"\n    ]\n\n    trace = [\n        \"GREEN_\",\n        \"YELLOW\",\n        \"RED___\",\n        \"GREEN_\",\n        \"YELLOW\",\n        \"RED___\",\n        \"GREEN_\"\n    ]\n\n    trace = [\n        \"RED___\",\n        \"GREEN_\",\n        \"YELLOW\",\n        \"RED___\",\n        \"GREEN_\",\n        \"YELLOW\",\n        \"RED___\"\n    ]\n\nEnd\n\n---\n\nDoes **ending state** matter?\n\n    trace = [\n        \"RED___\",\n        \"GREEN_\",\n        \"YELLOW\",\n        \"RED___\",\n        \"GREEN_\",\n        \"YELLOW\",\n        \"RED___\"\n    ]\n\n    trace = [\n        \"GREEN_\",\n        \"YELLOW\",\n        \"RED___\",\n        \"GREEN_\",\n        \"YELLOW\",\n        \"RED___\",\n        \"GREEN_\"\n    ]\n\n    trace = [\n        \"YELLOW\",\n        \"RED___\",\n        \"GREEN_\",\n        \"YELLOW\",\n        \"RED___\",\n        \"GREEN_\",\n        \"YELLOW\"\n    ]\n\nLength\n------\n\nDoes **length** matter?\n\n    trace = [\n        \"YELLOW\",\n        \"RED___\",\n        \"GREEN_\",\n        \"YELLOW\",\n        \"RED___\"\n    ]\n\n    trace = [\n        \"YELLOW\",\n        \"RED___\",\n        \"GREEN_\",\n        \"YELLOW\",\n        \"RED___\",\n        \"GREEN_\"\n    ]\n\n    trace = [\n        \"YELLOW\",\n        \"RED___\",\n        \"GREEN_\",\n        \"YELLOW\",\n        \"RED___\",\n        \"GREEN_\",\n        \"YELLOW\"\n    ]\n\nUnique\n------\n\nDoes the number of **unique states** matter?\n\n    trace = [\n        \"YELLOW\"\n    ]\n\n    trace = [\n        \"YELLOW\",\n        \"RED___\"\n    ]\n\n    trace = [\n        \"YELLOW\",\n        \"RED___\",\n        \"GREEN_\"\n    ]\n\norder\n-----\n\nDoes **order** matter?\n\n    trace = [\n        \"GREEN_\",\n        \"YELLOW\"\n    ]\n\n    trace = [\n        \"RED___\",\n        \"YELLOW\",\n    ]\n\n    trace = [\n        \"GREEN_\",\n        \"RED___\"\n    ]\n\nSets of Traces\n--------------\n\nA **trace property** is a set of traces.\n\nThe variable \"property\" is a list of traces.\n\n    property[0] = [\"GREEN_\"]\n    property[1] = [\"YELLOW\"]\n    property[2] = [\"RED___\"]\n    property[3] = [\"GREEN_\", \"YELLOW\"]\n    \n\nSystem Properties\n-----------------\n\n*   A **security policy** has some given **property** if all possible traces produced by a system following said security policy are traces within the given property.\n*   This may be an infinite number of traces or include traces of infinite length.\n*   Systems may have more than one property.\n\n**Logics of specification** are used to specify properties - more on that latter.\n\nOn Security\n-----------\n\nProperties provide a way to answer the \"How?\" after asking:\n\n*   **What** is secure?\n*   **For whom** is the 'what' secure?\n*   **From whom** is the 'what' secure?\n\n\n\nSpecifications\n==============\n\nCalvin (Deutschbein)  \n\n07 February 2024\n\nAnnouncements\n-------------\n\n*   Welcome to DATA-599: Cybersecurity!\n*   There was no homework but is a lingering in-class exercise.\n    *   Not to worry! I have something for next week.\n    \n*   Let's talk about how to specify properties.\n\n\nProperties\n----------\n\n*   An **security policy** may have **properties**.\n*   These **security policies** are distinct from the **what?** of a threat model\n*   Rather the **security policy** is the **how?** of a threat model\n\nA security policy could be\n\n    nonresident_at_door -> door_locked\n\n \n\nTrace Properties\n----------------\n\n*   A **trace** is the sequence of states through which a system passes over time.\n    *   A **sequence** is an ordering of something. So traces are **in order**.\n    *   A **state** is the configuration of a system at some specific time point.\n    *   A **system** here is the entity that implements the security policy\n    *   We emphasize the notion of **over time**. Traces are **time-based**\n\nSets of Traces\n--------------\n\nA **set** is an ordered collection of elements (such as sequences).\n\nA **sequence** is an ordered collection of elements (such as states).\n\nA **trace property** is a set of traces.\n\nA **trace** is a sequence of states.\n\nOrganization\n------------\n\nExample\n-------\n\nEnumeration\n-----------\n\nLast class, we enumerated the possible traces.\n\n    property[0] = [\"GREEN_\"]\n    property[1] = [\"YELLOW\"]\n    property[2] = [\"RED___\"]\n    property[3] = [\"GREEN_\", \"YELLOW\"]\n    \n\nTalk\n----\n\nLet's do examples as a class until we feel good about them.\n\nEnumeration\n-----------\n\nLast class, we enumerated the possible traces.\n\n    property[0] = [\"GREEN_\"]\n    property[1] = [\"YELLOW\"]\n    property[2] = [\"RED___\"]\n    property[3] = [\"GREEN_\", \"YELLOW\"]\n    \n\nThis is bad. Why?\n\nSpecification\n-------------\n\nRather than enumerate, let us specify.\n\n    The traffic light property is\n    the set of all sequences over precisely the states {\"GREEN_\", \"YELLOW\", \"RED___\"} \n    such that \n    the only state succeeding \"GREEN_\" is \"YELLOW\" and\n    the only state succeeding \"YELLOW\" is \"RED___\" and\n    the onle state succeeding \"RED___\" is \"GREEN_\".\n    \n\nThis is still bad. Why?\n\nModel Checking\n--------------\n\nA Kripke Structure is a tuple that models a state machine.\n\nA **state machine** is a mathematical model of computation. It is an abstract machine that can be in exactly one of a finite number of states at any given time.\n\nModel Checking\n--------------\n\nA Kripke Structure is a tuple {_S_, ...} that models a state machine.\n\n*   _S_ is a finite set of states\n    *   Kripke structures only work for **finite** state machines\n    *   For the sake of this class, we can imagine infinite states if needed.\n\nModel Checking\n--------------\n\nA Kripke Structure is a tuple {_S_, ...} that models a state machine.\n\n*   For a traffic light, _S_ is:\n    \n        {\"GREEN_\", \"YELLOW\", \"RED___\"}\n    \n*   For a commerical airliner, _S_ is all combinations of people on the airliner and locations on the airliner.\n    *   One element of _S_ over 2 crew and 1 passenger could be:\n        \n            {[\"CRW1\", \"DECK\"], [\"CRW2\", \"SERV\"], [\"PSG1\",\"SEAT\"]}\n        \n\nModel Checking\n--------------\n\nA Kripke Structure is a tuple {_S_, _I_, ...} that models a state machine.\n\n*   _I_ is a subset of _S_, we denote this _I_ ⊂ _S_\n    *   Any state in _I_ must be a state in _S_\n    *   There may be states in _S_ that are not in _I_\n    *   These are the possible initial states of the state machine.\n\nModel Checking\n--------------\n\nA Kripke Structure is a tuple {_S_, _I_, ...} that models a state machine.\n\n*   For a traffic light, _I_ = _S_\n    \n        {\"GREEN_\", \"YELLOW\", \"RED___\"}\n    \n*   For an airliner, _I_ is all elements of _S_ such that all passengers are seated.\n    *   One element of _I_ and therefore _S_ could be:\n        \n            {[\"CRW1\", \"DECK\"], [\"CRW2\", \"SERV\"], [\"PSG1\",\"SEAT\"]}\n        \n    *   One element of _S_ but not _I_ could be:\n        \n            {[\"CRW1\", \"DECK\"], [\"CRW2\", \"SERV\"], [\"PSG1\",\"DECK\"]}\n        \n\nModel Checking\n--------------\n\nA Kripke Structure is a tuple {_S_, _I_, ...} that models a state machine.\n\n*   _S_ is a finite set of states\n*   _I_ ⊂ _S_ is the set of initial states.\n\nModel Checking\n--------------\n\nA Kripke Structure is a tuple {_S_, _I_, _R_, ...} that models a state machine.\n\n*   _R_ is a **transition relation** over _S_, we denote this _R_ ⊂ _S_ × _S_\n    *   This just means _R_ says whether one state may be transitioned to from another.\n    *   _R_ expresses them enumerating sequences of length two, called **ordered pairs**\n        *   A starting state\n        *   An ending state\n        *   These states are the states in _S_\n\nModel Checking\n--------------\n\nA Kripke Structure is a tuple {_S_, _I_, _R_, ...} that models a state machine.\n\n*   _R_ is a **transition relation** over _S_, we denote this _R_ ⊂ _S_ × _S_\n    *   This just means _R_ says whether one state may be transitioned to from another.\n    *   _R_ expresses them enumerating sequences of length two, called **ordered pairs**\n*   **BONUS/CHALLENGE:** _R_ is left-total.\n    \n    A binary relation _R_ ⊂ _S_ × _S_ is **left-total** if for all elements _s_ of _S_ there exists some ordered pair in _R_ such that the first element of the ordered pair is _s_.\n    \n    _R_ ⊂ _S_ × _S_ is **left-total** ≔ ∀ _s1_ ∈ _S_, ∃ _s2_ ∈ _S_ such that (_s1_,_s2_) ∈ _R_\n    \n\nModel Checking\n--------------\n\nA Kripke Structure is a tuple {_S_, _I_, _R_, ...} that models a state machine.\n\n*   For a traffic light, _R_ is:\n    \n        {(\"GREEN_\", \"YELLOW\"),\n         (\"YELLOW\", \"RED___\"),\n         (\"RED___\", \"GREEN_\")}\n    \n*   For a commerical airliner, _R_ must describe how crew may not move to the service station when passengers are present and vice versa, or some other arrangement.\n    *   Note: Relations may be used to to express the arrangement of people on an airliner as well as express transition relations.\n\nModel Checking\n--------------\n\nA Kripke Structure is a tuple {_S_, _I_, _R_, ...} that models a state machine.\n\n*   _S_ is a finite set of states\n*   _I_ ⊂ _S_ is the set of initial states.\n*   _R_ ⊂ _S_ × _S_ is a left-total transition relation.\n\nModel Checking\n--------------\n\nA Kripke Structure is a 4-tuple {_S_, _I_, _R_, _L_} that models a state machine.\n\n*   _L_ is a **labeling function** over _S_, we denote this _L_ ⊂ _S_ → ???\n    *   This just means _L_ provides a way of talking about the states in _S_\n    *   We talk about these states using **atomic propositions**\n        *   Propositions are expressions in propositional, or zeroth order, logic.\n        *   They are simply true or false.\n        *   Atomic propositions are simplest possible form of these logic expressions.\n    *   _L_ ⊂ _S_ → 2_AP_\n\nModel Checking\n--------------\n\nA Kripke Structure is a 4-tuple {_S_, _I_, _R_, _L_} that models transitions between over atomic propositions _AP_.\n\n*   _L_ is a **labeling function** over _S_, we denote this _L_ ⊂ _S_ → 2_AP_\n    *   Given _AP_, _L_ tells us whether each is true or false (2 options) for every given state.\n\nModel Checking\n--------------\n\nA Kripke Structure is a 4-tuple {_S_, _I_, _R_, _L_} that models transitions and _AP_.\n\n*   For a traffic light, _AP_ could be the following, expressed as a proposition set:\n    \n        {s == \"GREEN_\", \n         s == \"YELLOW\", \n         s == \"RED___\", \n         s ∈ {\"GREEN_\", \"YELLOW\"},\n         s ∈ {\"YELLOW\", \"RED___\"},\n         s ∈ {\"RED___\", \"GREEN_\"}}\n    \n*   Propositions are often named using single lower cases letters in italics beginning with _p_\n\nModel Checking\n--------------\n\nA Kripke Structure is a 4-tuple {_S_, _I_, _R_, _L_} that models transitions and _AP_.\n\n*   For a traffic light, _AP_ could be the following:\n    \n        AP = \n        [p : state == \"GREEN_\", \n         q : state == \"YELLOW\", \n         r : state == \"RED___\", \n         s : state ∈ {\"GREEN_\", \"YELLOW\"},\n         t : state ∈ {\"YELLOW\", \"RED___\"},\n         u : state ∈ {\"RED___\", \"GREEN_\"}]\n    \n*   Then the _L_ would be given as :\n    \n        {(\"GREEN_\", {p, s, u}), \n         (\"YELLOW\", {q, s, t}),\n         (\"RED___\", {r, t, u})}\n    \n\nModel Checking\n--------------\n\nA Kripke Structure is a 4-tuple {_S_, _I_, _R_, _L_} that models transitions and _AP_.\n\n*   For a commercial airliner, we may want to use _AP_ more intentionally:\n    *   Let _p_ denote there are passengers at the service station.\n    *   Let _q_ denote there are crew at the service station.\n    *   Let _r_ denote there all passengers are seated.\n    *   Let _s_ denote at least two crew are in the flight deck.\n\nModel Checking\n--------------\n\nA Kripke Structure is a 4-tuple {_S_, _I_, _R_, _L_} that models transitions and _AP_.\n\n*   _S_ is a finite set of states\n*   _I_ ⊂ _S_ is the set of initial states.\n*   _R_ ⊂ _S_ × _S_ is a left-total transition relation.\n*   _L_ ⊂ _S_ → 2_AP_ is the labelling relation.\n\nModel Checking\n--------------\n\nA Kripke Structure is a 4-tuple {_S_, _I_, _R_, _L_} that models transitions and _AP_.\n\n*   _S_ is a finite set of states and _I_ ⊂ _S_ is the set of initial states.\n\n    {\"GREEN_\", \"YELLOW\", \"RED___\"}\n\n*   _R_ ⊂ _S_ × _S_ is a left-total transition relation.\n\n    {(\"GREEN_\", \"YELLOW\"), \n     (\"YELLOW\", \"RED___\"), \n     (\"RED___\", \"GREEN_\")}\n\n*   _L_ ⊂ _S_ → 2_AP_ is the labelling relation.\n\n    {(\"GREEN_\", {p, s, u}),\n     (\"YELLOW\", {q, s, t}), \n     (\"RED___\", {r, t, u})}\n\nA Kripke Structure modelling a traffic light is the 4-tuple...\n\n    ({\"GREEN_\", \"YELLOW\", \"RED___\"}, \n     {\"GREEN_\", \"YELLOW\", \"RED___\"}, \n     {(\"GREEN_\", \"YELLOW\"), \n      (\"YELLOW\", \"RED___\"), \n      (\"RED___\", \"GREEN_\")}, \n     {(\"GREEN_\", {p, s, u}),\n      (\"YELLOW\", {q, s, t}), \n      (\"RED___\", {r, t, u})})\n\n...over _AP_...\n\n    [p : state == \"GREEN_\",  \n     q : state == \"YELLOW\",  \n     r : state == \"RED___\",  \n     s : state ∈ {\"GREEN_\", \"YELLOW\"},\n     t : state ∈ {\"YELLOW\", \"RED___\"},\n     u : state ∈ {\"RED___\", \"GREEN_\"}]\n\nModel Checking\n--------------\n\nA Kripke Structure is a 4-tuple {_S_, _I_, _R_, _L_} that models transitions and _AP_.\n\n*   This is still bad. Why?\n\nDiagrams\n--------\n\nNow that I've rigorously defined Kripke Structures, I am willing to tell you they are just diagrams.\n\n*   Clarke, Edmund & Grumberg, Orna & Jha, Somesh & Lu, Yuan & Veith, Helmut. (2003). Counterexample-guided abstraction refinement for symbolic model checking. J. ACM. 50. 752-794. 10.1145/876638.876643.\n\nDiagrams\n--------\n\nThis differs from ours, but only slightly.\n\n*   The proposition labels are the same as the state name initials.\n*   _r_ is the only accepted starting state.\n*   States are allowed to transition to the themselves\n    *   Think of this is a distinct notion of time.\n        *   I describe the only thing that changes time as a change in state.\n        *   If we imagine that there is a transition every second, the green-to-green is needed.\n\nDiagrams\n--------\n\n*   We borrow the initials-labels trick.\n*   We allow all starting states.\n*   We do not have states transition to themselves.\n\nDiagrams\n--------\n\nA Kripke Structure is a 4-tuple {_S_, _I_, _R_, _L_}\n\n*   _S_ is the states, in blue.\n\nDiagrams\n--------\n\nA Kripke Structure is a 4-tuple {_S_, _I_, _R_, _L_}\n\n*   _S_ is the states, in blue.\n*   _I_ is the inital states, in orange.\n*   _R_ is the relations, in purple.\n\nDiagrams\n--------\n\nA Kripke Structure is a 4-tuple {_S_, _I_, _R_, _L_}\n\n*   _S_ is the states, in blue.\n*   _I_ is the inital states, in orange.\n*   _R_ is the relations, in purple.\n*   _L_ is the labels, in black.\n\nLimitations\n-----------\n\nKripke Structures are better than enumeration, but...\n\n*   Representation in text is difficult to understand\n*   Showing equivalence to traces can be difficult\n\n![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRZyXOm5FuHroH2uEG4BZupE8XNYP0scFZAyQ&usqp=CAU)\n\nWe will introduce a better way to write out relations, then look at our Kripke Structures.\n\nAn example\n----------\n\nConsider the following Kripke Structure:\n\n![](https://upload.wikimedia.org/wikipedia/commons/3/3b/KripkeStructureExample.svg)\n\nThe following statements are true of traces accepted by this structure:\n\n*   `p` and `q` are true initially.\n*   Once `q` becomes false, it never becomes true again.\n*   Once `q` becomes false, `p` stays true forever.\n*   `p` goes from false to true when `q` goes from true to true false.\n\nA concretization\n----------------\n\nConsider the following representation:\n\n*   Take `p` to be \"password checking is blocked/secured\"\n*   Take `q` to be \"system access is blocked/secured\"\n\nA passwording service **must** disclose if an entered password is correct.\n\n*   `p` and `q` are true initially.\n    *   No checking, no access\n*   Once `q` becomes false, it never becomes true again.\n    *   Once logged in, we can no longer guess passwords.\n*   Once `q` becomes false, `p` stays true forever.\n    *   Once logged in, access is not revoked.\n\nInfinite guesses (bad), but persistent users may not look up passwords (good).\n\nGoals\n-----\n\nWe have:\n\n*   A way to describe the current state of the system (_AP_)\n\nWe need:\n\n*   A way to describe relations between atomic propositions over time.\n\nConsider:\n\n*   `p` and `q` are true **initially**.\n*   Once `q` becomes false, it never becomes true again.\n    *   `q` until not `q`\n*   Once `q` becomes false, `p` stays true forever.\n    *   `q` until not `q`\n*   `p` goes from false to true when `q` goes from true to true false.\n    \n\nNext and Until\n--------------\n\nIt often suffices to define two temporal operators:\n\n*   **X**: “next”\n*   **U**: “until”\n\nAlong with existing logical operators:\n\n*   **¬**: “not”\n*   **∨**: “or”\n\nWe need apply this over atomic propositions in _AP_ to describe the security requirements of a system.\n\n\\>\n\nComposition\n-----------\n\nWith logical negation (not) and disjunction (or) we can generate other logical connectives.\n\n_p_\n\n_q_\n\n**¬**_p_\n\n_p_**∨**_q_\n\n**¬**_p_**∨****¬**_q_\n\n**¬**(**¬**_p_**∨****¬**_q_)≡_p_**∧**_q_\n\nTrue\n\nTrue\n\nFalse\n\nTrue\n\nFalse\n\nTrue\n\nTrue\n\nFalse\n\nFalse\n\nTrue\n\nTrue\n\nFalse\n\nFalse\n\nTrue\n\nTrue\n\nTrue\n\nTrue\n\nFalse\n\nFalse\n\nFalse\n\nTrue\n\nFalse\n\nTrue\n\nFalse\n\nFor example, \"and\" or conjunction over two atomic propositions is equivalent to the negation or \"not\" of the \"or\" or disjunction over the negation or \"not\" of the two atomic propositions.\n\nNext and Until\n--------------\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/xu.png)\n\n**X** _a_\n\n*   \\* → _a_ → \\* → ...\n\n_a_ **U** _b_\n\n*   _a_**∧****¬**_b_ → _b_ → \\* → ...\n*   _a_**∧****¬**_b_ → _a_**∧****¬**_b_ → _b_ → \\* → ...\n\nLinear Temporal Logic Composition\n---------------------------------\n\nName\n\nUsage\n\nMeaning\n\nEquivalencies\n\nneXt\n\n**X** _p_\n\n_p_ holds in the next time\n\n**X** _p_\n\nFuture\n\n**F** _p_\n\n_p_ holds in some future time\n\nTrue**U**_p_\n\nGlobal(ly)\n\n**G** _p_\n\n_p_ holds in all future times\n\n**¬**(True**U****¬**_p_)\n\nUntil\n\n_p_ **U** _q_\n\n_p_ holds unless _q_, and _q_ must hold at some point in the future\n\n_p_ **U** _q_\n\nRelease\n\n_p_ **R** _q_\n\n_q_ holds up to and including when _p_ holds\n\n**¬**(**¬**_p_ **U** **¬**_q_)\n\nWeak until\n\n_p_ **W** _q_\n\n_p_ holds up to when _q_ holds\n\n(_p_ **U** _q_) ∨ **G** _p_\n\nMighty release\n\n_p_ **M** _q_\n\n_q_ holds up to and including when _p_ holds, and _p_ must hold at some point in the future\n\n_q_ **U** (_p_ **∨**_q_)\n\nLinear Temporal Logic Exercise\n------------------------------\n\nPopulate this table in groups of _n_. Likely 15-20 minutes.\n\nOperator\n\nTrace 1\n\nTrace 2\n\n**X** _p_\n\n\\* → _p_ → \\* → ...\n\n**F** _p_\n\n?\n\n?\n\n**G** _p_\n\n?\n\n_p_ **U** _q_\n\n_p_**∧****¬**_q_ → _p_**∧****¬**_q_ → _q_ → \\* → ...\n\n_p_ **R** _q_\n\n?\n\n?\n\n_p_ **W** _q_\n\n?\n\n?\n\n_p_ **M** _q_\n\n?\n\nLinear Temporal Logic Traces\n----------------------------\n\nOperator\n\nTrace 1\n\nTrace 2\n\n**X** _p_\n\n\\* → _p_ → \\* → ...\n\n**F** _p_\n\n\\* → _p_ → \\* → ...\n\n\\* → \\* → _p_ → \\* → ...\n\n**G** _p_\n\n_p_ → _p_ → _p_ → ...\n\n_p_ **U** _q_\n\n_p_**∧****¬**_q_ → _p_**∧****¬**_q_ → _q_ → \\* → ...\n\n_p_ **R** _q_\n\n_q_ → _q_ → _p_ **∧** _q_ → \\* → ...\n\n_q_ → _q_ → _q_ → ...\n\n_p_ **W** _q_\n\n_p_ → _p_ → _q_ → \\* → ...\n\n_p_ → _p_ → _p_ → ...\n\n_p_ **M** _q_\n\n_q_ → _q_ → _p_ **∧** _q_ → \\* → ...\n\n\nShorthand\n---------\n\nLet's introduce a wrinkle.\n\nThe LTL operator **neXt** denotes that some atomic proposition should hold true in the next time point. We can generalize this to some fixed future timepoint but using more than one next. For example, the expression:\n\n**XXXX**_p_**∧****¬**_q_\n\nholds over the following trace:\n\n    {p,q}, {q  }, {p,q}, {q  }, {p  }, {p  }, {p  }, ...\n\nWe extend **neXt** to reference a fixed future timepoint using a superscript:\n\n**X**4_p_**∧****¬**_q_\n\nI term this \"multinext\".\n\nReview Question 3\n-----------------\n\nConsider the following trace:\n\n    {p,q}, {q  }, {p,q}, {q  }, {p  }, {p  }, {p  }, ...\n\nWhich of the following LTL expressions would describe this trace?\n\n1.  **¬****X**1_q_\n2.  **¬****X**2_q_\n3.  **¬****X**3_q_\n4.  **¬****X**4_q_\n\nReview Question 4\n-----------------\n\nConsider the following trace:\n\n    {p,q}, {q  }, {p,q}, {q  }, {p  }, {p  }, {p  }, ...\n\nWhich of the following LTL expressions would describe this trace?\n\n1.  _q_ **U** **G**_p_\n2.  _q_ **R** **G**_p_\n3.  _q_ **W** **G**_p_\n4.  _q_ **M** **G**_p_\n\nCheck your notes or the slides!\n\nReview Question 5\n-----------------\n\nConsider the following Kripke Structure:\n\n![](https://upload.wikimedia.org/wikipedia/commons/3/3b/KripkeStructureExample.svg)\n\nWhich of the following LTL expressions would describe this structure?\n\n1.  _q_ **U** **G**_p_\n2.  _q_ **R** **G**_p_\n3.  _q_ **W** **G**_p_\n4.  _q_ **M** **G**_p_\n\nReview Question 6\n-----------------\n\nConsider the following Kripke Structure:\n\n![](https://upload.wikimedia.org/wikipedia/commons/3/3b/KripkeStructureExample.svg)\n\nWhich of the following LTL expressions would would describe this structure?\n\n1.  **X**1_q_\n2.  **X**2_q_\n3.  **X**3_q_\n4.  **X**4_q_\n\nReview Question 7\n-----------------\n\nConsider the following Kripke Structure:\n\n![](https://upload.wikimedia.org/wikipedia/commons/3/3b/KripkeStructureExample.svg)\n\n10-15 min: In small groups, define an equivalent LTL expression to this structure.\n\nProperties\n----------\n\n*   Some security properties are about bad things not happening:\n    *   **G****¬**_bad_\n    *   Term this \"safety\"\n*   Some security properties are about good things happening someday:\n    *   **F**_good_\n    *   Term this \"liveness\"\n*   These **security policies** are distinct but difficult to differentiate in Kripke Structures.\n*   For non-experts, it may be helpful to formulate security properties that differentiate these.\n\n\"I want to be able to access my apartment sometimes but I don't want adversaries to be able to access it ever.\"\n\nBüchi Automata\n--------------\n\n*   Logicians use Büchi Automata to define **safety** and **liveness** more formally.\n*   Büchi Automata are more expressive than Kripke Structures\n*   Deterministic Büchi Automata are equivalent to LTL\n    *   What would it mean for a Kripke Structure to be deterministic?\n    *   What would it mean for LTL not to be deterministic?\n\nWe define Büchi Automata as we did Kripke Structures, then show their usefulness.\n\nBüchi Automata\n--------------\n\nA deterministic Büchi Automaton either accepts or rejects infinite inputs (traces).\n\nBüchi Automata\n--------------\n\nA deterministic Büchi Automaton _A_ is a tuple {_Q_, ...} that accepts traces.\n\n*   _Q_ is a finite set.\n    *   We term the elements of _Q_ to be the states of _A_\n    *   The states of _A_ may be distinct from the unique states found within a trace.\n    *   Traces of infinite length can be considered.\n*   _Q_ is circles in our diagram.\n\nBüchi Automata\n--------------\n\nA deterministic Büchi Automaton _A_ is a tuple {_Q_, _Σ_,...} that accepts traces.\n\n*   _Σ_ (sigma) is a finite set.\n    *   We term _Σ_ the alphabet of _A_\n    *   _Σ_ is the unique states found within a trace.\n    *   We use _Σ_ ω (upper case sigma raised to lower case omega) to denote infinite traces\n    *   These are the possible states of a trace; I term them letters.\n\nBüchi Automata\n--------------\n\nA deterministic Büchi Automaton _A_ is a tuple {_Q_, _Σ_,...} that accepts traces _Σ_ ω.\n\n*   _Q_ is a finite set: the states of _A_.\n*   _Σ_ is a finite set: the alphabet of _A_.\n\nWe studied example traces earlier, for these:\n\n    Σ = { {'p', 'q'}, {'p'}, {'q'} }\n\nWe cannot yet generate something that looks like _Q_, but it is similar to\n\n    Q ≈ {'s_1', 's_2', 's_3'}\n\n![](https://upload.wikimedia.org/wikipedia/commons/3/3b/KripkeStructureExample.svg)\n\nBüchi Automata\n--------------\n\nA deterministic Büchi Automaton _A_ is a tuple {_Q_, _Σ_, _δ_, ...} that accepts traces _Σ_ ω.\n\n*   _δ_ is a function.\n    *   We term _δ_ (lower case delta) the transition function of _A_.\n    *   _δ_ maps combinations of states and letters to other states.\n    *   _δ_ : _Q_ × _Σ_ **→** _Q_, or\n    *   _δ_ ⊆ (_Q_ × _Σ_ ) × _Q_\n*   _δ_ is like Kripke _R_ except that it has to check both _Q_ (model) and _Σ_ (trace).\n*   _δ_ takes a circle in the diagram and an observation and tells you the new circle in the diagram.\n*   _Σ_ labels arrows between circles in the diagram.\n\nBüchi Automata\n--------------\n\nA deterministic Büchi Automaton _A_ is a tuple {_Q_, _Σ_, _δ_,...} that accepts traces.\n\n*   _Q_ is a finite set: the states of _A_.\n*   _Σ_ is a finite set: the alphabet of _A_.\n*   _δ_ : _Q_ × _Σ_ **→** _Q_ is a function: the transition function of _A_.\n\nBüchi Automata\n--------------\n\nA deterministic Büchi Automaton _A_ is a tuple {_Q_, _Σ_, _δ_, _q0_,...} that accepts traces _Σ_ ω.\n\n*   _q0_ ∈ _Q_ (say: q-naut is an element of the seq Q)\n    *   We term _q0_ the initial state of _A_.\n    *   _q0_ is like _I_ but Büchi Automata have only a single starting state.\n        *   This is because Büchi Automata have no atomic proposition labels on states, only on transitions.\n    \n\nBüchi Automata\n--------------\n\nA deterministic Büchi Automaton _A_ is a tuple {_Q_, _Σ_, _δ_, _q0_,...} that accepts traces _Σ_ ω.\n\n*   _Q_ is a finite set: the states of _A_.\n*   _Σ_ is a finite set: the alphabet of _A_.\n*   _δ_ : _Q_ × _Σ_ **→** _Q_ is a function: the transition function of _A_.\n*   _q0_ ∈ _Q_: is a state: the initial state of _A_\n\nBüchi Automata\n--------------\n\nA deterministic Büchi Automaton _A_ is a tuple {_Q_, _Σ_, _δ_, _q0_, **F** } that accepts traces _Σ_ ω.\n\n*   **F** ⊆ _Q_ is a non-strict subset.\n    *   We term **F** the acceptance condition.\n    *   This one looks a bit odd on slides, it looks clearer standard formatting.\n        *   **F** is bolded\n        *   _Q_ is italicized\n        *   F ⊆ Q|\n    *   An infinite trace must visit states in **F** an infinite number of times to be accepted.\n    *   We can think of finite traces as infinitely repeated their last state, which must be in **F**.\n\nBüchi Automata\n--------------\n\nA deterministic Büchi Automaton _A_ is a tuple {_Q_, _Σ_, _δ_, _q0_, **F** } that accepts traces _Σ_ ω.\n\n*   _Q_ is a finite set: the states of _A_.\n*   _Σ_ is a finite set: the alphabet of _A_.\n*   _δ_ : _Q_ × _Σ_ **→** _Q_ is a function: the transition function of _A_.\n*   _q0_ ∈ _Q_: is a state: the initial state of _A_\n*   **F** ⊆ _Q_ is a non-strict subset: the acceptance condition\n\nDiagrams\n--------\n\nKripke Structures\n\nBüchi Automata\n\n*   Both (graphs) have a circles (nodes) and arrows (edges)\n    *   Kripke Structures label circles (nodes)\n    *   Büchi Automata label arrows (edges)\n\nDiagrams\n--------\n\n_A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** }\n\n*   _Q_ : the states of _A_.\n*   _Σ_ : the alphabet of _A_.\n*   _δ_ : _Q_ × _Σ_ **→** _Q_ : transition function.\n*   _q0_ ∈ _Q_ : the initial state of _A_\n*   **F** ⊆ _Q_ : the acceptance condition\n\nTraffic Light\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/buchi.png)\n\nDiagrams\n--------\n\n_A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** }\n\n*   _Q_ = { _q0, q1, q2_} in cyan\n*   _Σ_ : the alphabet of _A_.\n*   _δ_ : _Q_ × _Σ_ **→** _Q_ : transition function.\n*   _q0_ ∈ _Q_ : the initial state of _A_\n*   **F** ⊆ _Q_ : the acceptance condition\n\nTraffic Light\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/buchi2.png)\n\nDiagrams\n--------\n\n_A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** }\n\n*   _Q_ = { _q0, q1, q2_} in cyan\n*   _Σ_ = {_red, green, yellow_} in magenta\n*   _δ_ : _Q_ × _Σ_ **→** _Q_ : transition function.\n*   _q0_ ∈ _Q_ : the initial state of _A_\n*   **F** ⊆ _Q_ : the acceptance condition\n\nTraffic Light\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/buchi3.png)\n\nDiagrams\n--------\n\n_A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** }\n\n*   _Q_ = { _q0, q1, q2_} in cyan\n*   _Σ_ = {_red, green, yellow_} in magenta\n*   _δ_ : _Q_ × _Σ_ **→** _Q_ in blue\n    *   Take ((_q0, red_), _q0_) as `0R0`\n    *   _δ_ =`{0R0,0G1,1G1,1Y2,2Y2,2R0}`\n*   _q0_ ∈ _Q_ : the initial state of _A_\n*   **F** ⊆ _Q_ : the acceptance condition\n\nTraffic Light\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/buchi4.png)\n\nDiagrams\n--------\n\n_A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** }\n\n*   _Q_ = {_0, 1, 2_ } in cyan\n*   _Σ_ = {_R, G, Y_ } in magenta\n*   _δ_ = `{R0G1,G1Y2,Y2R0}` in blue\n*   _q0_ or _0_ : in orange\n*   **F** ⊆ _Q_ : the acceptance condition\n\nTraffic Light\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/buchi5.png)\n\nDiagrams\n--------\n\n_A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** }\n\n*   _Q_ = {_0, 1, 2_ } in cyan\n*   _Σ_ = {_R, G, Y_ } in magenta\n*   _δ_ = `{R0G1,G1Y2,Y2R0}` in blue\n*   _q0_ or _0_ in orange\n*   **F** = {_q0_} or {_0_} in black\n\nTraffic Light\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/buchi5.png)\n\nSafety and Liveness\n-------------------\n\nSafety\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/safe.png)\n\nLiveness\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/live.png)\n\nSafety\n------\n\n*   Some security properties are about bad things not happening:\n    *   **G****¬**_bad_\n    *   Term this \"safety\"\n*   If a Büchi Automata is a safety property...\n    *   If the bad things happens, the system is unrecoverable.\n    *   Therefore, any failures result from \"falling off\" the diagram.\n    *   Therefore, all states are accepting states (no failures based on ending).\n\nSafety\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/safe.png)\n\nSafety\n------\n\nThe **closure** of Büchi Automaton given by _A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** } is _cl(A)_ ≔ {_Q_, _Σ_, _δ_, _q0_, _Q_ }.  \n  \nThat is, _cl(A)_ is equivalent to _A_ if the set of accepting states **F** is expanded to include all of the states of _A_\n\n<\n\nA **safety property** is a property given by a Büchi Automaton _A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** } such that all traces accepted by _A_ are also accepted by its _cl(A)_ ≔ {_Q_, _Σ_, _δ_, _q0_, _Q_ }.\n\nSafety\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/safe.png)\n\nSafety\n------\n\n*   This means, we can develop safety properties from arrows (edges), or from _δ_\n    *   We see that yellow is always preceded by green or yellow.\n    *   Yellow is never preceded by red.\n    *   So we can say that the bad thing is red with yellow next\n    *   **G****¬**(_red_∧**X**_yellow_ )\n    *   **G****¬**(_green_∧**X**_red_ )\n    *   **G****¬**(_yellow_∧**X**_green_ )\n\nSafety\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/safe.png)\n\nSafety\n------\n\nCould we argue that only **G****¬**(_green_∧**X**_red_ ) is a safety property?\n\n  \n\n15-20 min: In small groups, define the Büchi Automaton that captures \\*only\\* this safety property.\n\n  \n\nA diagram is sufficient, but think about _A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** }\n\n  \n\nBe prepared to demonstrate that you have created a safety property!\n\nSafety\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/safe.png)\n\nLiveness\n--------\n\n*   Some security properties are about good things happening someday:\n    *   **F**_good_\n    *   Term this \"liveness\"\n*   If a Büchi Automata is a liveness property...\n    *   No matter what happens, the system is recoverable.\n    *   Therefore, any failures result from not reaching accepting states.\n    *   Therefore, all states should have outgoing edges covering all letters of the trace alphabet.\n\nLiveness\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/live.png)\n\nLiveness\n--------\n\nThe **closure** of Büchi Automaton given by _A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** } is _cl(A)_ ≔ {_Q_, _Σ_, _δ_, _q0_, _Q_ }.  \n  \nThat is, _cl(A)_ is equivalent to _A_ if the set of accepting states **F** is expanded to include all of the states of _A_\n\n<\n\nA **liveness property** is a property given by a Büchi Automaton _A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** } such that _cl(A)_ ≔ {_Q_, _Σ_, _δ_, _q0_, _Q_ } accepts all possible traces in _Σ_ ω.\n\nLiveness\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/live.png)\n\nLiveness\n--------\n\n*   This means, we can study liveness properties by adding a self-loop with negation of all other outgoing edges to each automaton state.\n    *   We see that _q1_ has an outgoing edge labelled \"yellow\".\n    *   We add an edge from _q1_ to itself that is labelled \"not yellow\".\n*   As a convenience, we say the \"good thing\" is the light turning green\n    *   We mark _q1_ as the accepting state, since it is reached when the light turns green.\n\nLiveness\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/live.png)\n\nLiveness\n--------\n\nCould we argue that only **F**_green_ is a Liveness property?\n\n  \n\n10-15 min: In small groups, define the Büchi Automaton that captures \\*only\\* this liveness property.\n\n  \n\nA diagram is sufficient, but think about _A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** }\n\n  \n\nBe prepared to demonstrate that you have created a safety property!\n\nLiveness\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/live.png)\n\n\nProperties\n----------\n\n\"I want to be able to access my savings but no one else.\"\n\n*   Safety properties are about bad things not happening:\n    *   **G****¬**_bad_\n    *   These are undefined transitions in Büchi automata\n    *   \"No one else may access my savings\"\n*   Liveness properties are about good things happening eventually:\n    *   **F**_good_\n    *   These are accepting states in Büchi automata\n    *   \"I want to be able to access my savings\"\n\nDiagrams\n--------\n\n_A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** }\n\n*   _Q_ = {_0, 1, 2_ } in cyan\n*   _Σ_ = {_R, G, Y_ } in magenta\n*   _δ_ = `{R0G1,G1Y2,Y2R0}` in blue\n*   _q0_ or _0_ in orange\n*   **F** = {_q0_} or {_0_} in black\n\nTraffic Light\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/buchi5.png)\n\nSafe() and Live()\n-----------------\n\nWe now define `Safe():`\n\n`Safe(m)` excludes the \"bad thing\" for a Buchi automaton, which is attempting an undefined transition, because if such a \"bad thing\" happens at any point in the trace, the Buchi automaton will not accept that trace.\n\n... and `Live()`:\n\n`Live(m)` requires the \"good thing\" for a Buchi automaton, which is entering an accepting state infinitely often, because we require this \"good thing\" to happen for trace to be accepted.\n\nIntersection\n------------\n\nWe recall set theoretic intersection...\n\nIn set theory, the intersection of two sets _A_ and _B_, denoted by _A_ **∩**_B_ is the set containing all elements of _A_ that also belong to _B_\n\n... and we recall what properties are:\n\nA **trace property** is a set of traces.\n\nAnd now we make our claim:\n\n\"Given a Buchi automaton `m`, it is not difficult to construct Buchi automata `Safe(m)` and `Live(m)` such that `Safe(m)` specifies a safety property, `Live(m)` specifies a liveness property, and the prop- erty specified by `m` is the intersection of those specified by Safe(m) and Live(m).\"\n\nExample\n-------\n\nConsider the following Büchi automata over the alphabet of lower case letters:\n\n![](https://upload.wikimedia.org/wikipedia/commons/5/56/Automate_de_Buchi2.jpg?20180829053802)\n\nSafety means **G**_a_ **∨** _b_\n\n    Safe(m) = {\"a\", \"b\", \"aa\", \"ab\", \"ba\", \"bb\", \"aaa\", \"aab\", ... }\n\nLiveness means **G****F**_a_\n\n    Live(m) = {\"a\", \"aa\", \"ba\", \"ca\", \"da\", \"ea\", \"fa\", \"ga\", ... }\n\nThe intersection represents elements in both `Safe(m)` and `Live(m)`...\n\nExample\n-------\n\nSafety means **G**_a_ **∨** _b_\n\n    Safe(m) = {\"a\", \"b\", \"aa\", \"ab\", \"ba\", \"bb\", \"aaa\", \"aab\", ... }\n\nLiveness means **G****F**_a_\n\n    Live(m) = {\"a\", \"aa\", \"ba\", \"ca\", \"da\", \"ea\", \"fa\", \"ga\", ... }\n\nThe intersection represents elements in both `Safe(m)` and `Live(m)`...\n\n    m = {\"a\", \"b\", \"aa\", \"ba\", \"aaa\", \"aba\", \"baa\", \"bba\", ... }\n\nTo continue to advance our understanding of the distinction, we explore how to generate `Safe(m)` and `Live(m)`.\n\nSafe()\n------\n\nWe recall the definition of safety.\n\n`Safe(m)` excludes the \"bad thing\" for a Buchi automaton, which is attempting an undefined transition, because if such a \"bad thing\" happens at any point in the trace, the Buchi automaton will not accept that trace.\n\nWe recall the definition of closure.\n\nThe **closure** of Büchi Automaton given by _A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** } is _cl(A)_ ≔ {_Q_, _Σ_, _δ_, _q0_, _Q_ }.  \n  \nSo_cl(A)_ is equivalent to _A_ if the set of accepting states **F** is expanded to include all of the states of _A_.\n\nA core \"nicety\" of Büchi Automata is that **the safety property is the closure**.\n\nSafe()\n------\n\nA core \"nicety\" of Büchi Automata is that **the safety property is the closure**.\n\n`Safe(m)` = `cl(m)`  \n  \nThat is, for `m` ≔ {_Q_, _Σ_, _δ_, _q0_, **F** } is `cl(m)` ≔ {_Q_, _Σ_, _δ_, _q0_, _Q_ }\n\nThe closure simply allows any trace without an undefined transition (or \"bad thing\") to be accepted.\n\nLive()\n------\n\nWe recall the definition of liveness.\n\n`Live(m)` requires the \"good thing\" for a Buchi automaton, which is entering an accepting state infinitely often, because we require this \"good thing\" to happen for trace to be accepted.\n\nThink back to our example (emphasis added):\n\n\"Consider the following Büchi automata **over the alphabet of lower case letters**\"\n\n![](https://upload.wikimedia.org/wikipedia/commons/5/56/Automate_de_Buchi2.jpg?20180829053802)\n\nWhile safety is mostly about **F**, the accepting states or the double circles, liveness is mostly about _Σ_ = `{a, b, ?}`, the alphabet or the possible states of the trace (NOT the states of the automata) that form the labels on arrows.\n\nLive()\n------\n\nSo we define liveness relative to _Σ_. There most be no undefined transitions (that would be safety) so we require that any letter in _Σ_ has a defined transition at any point in time. ![](https://cd-public.github.io/courses/old/secs24/slides/images/live.png)\n\nLive()\n------\n\nWith the traffic light, we ensured there were no undefined transitions using logical not \"**¬**\"\n\n  \n\nBut what does this logical not really do with respect to the alphabet?\n\nLiveness\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/live.png)\n\nLive()\n------\n\nLet's look back at our original _δ_ and _Σ_.\n\n*   _δ_ =`{0R0,0G1,1G1,1Y2,2Y2,2R0}`\n*   _Σ_ = {_R_, _G_, _Y_ }\n\nTo make a liveness property, we made sure that each of {_R_, _G_, _Y_ } had a defined place to go from each automata state. We added:\n\n*   _δlive(m)_ =`{0Y0,1R1,2G2}`\n\nBut this is ugly, let's look at a table\n\nLiveness\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/live.png)\n\nBefore Live()\n-------------\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/buchi.png)\n\n   \n\nTransition Letter\n\n_R_\n\n_G_\n\n_Y_\n\nInitial State\n\nNext State\n\n**_q0_**\n\n_q0_\n\n_q1_\n\n**UNDEFINED**\n\n_q1_\n\n**UNDEFINED**\n\n_q1_\n\n_q2_\n\n_q2_\n\n_q0_\n\n**UNDEFINED**\n\n_q2_\n\nWith Live()\n-----------\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/live.png)\n\n   \n\nTransition Letter\n\n_R_\n\n_G_\n\n_Y_\n\nInitial State\n\nNext State\n\n**_q0_**\n\n_q0_\n\n_q1_\n\n_q0_\n\n_q1_\n\n_q1_\n\n_q1_\n\n_q2_\n\n_q2_\n\n_q0_\n\n_q2_\n\n_q2_\n\nProblem\n-------\n\nThis _δ_ doesn't define a traffic light!\n\n*   _δlive(m)_ =\n    \n        {0R0,0G1,\n         1G1,1Y2,\n         2Y2,2R0,\n         0Y0,1R1,2G2}\n    \n*   _Σ_ = {_R_, _G_, _Y_}\n\nWe need a way to preserve existing state transitions, while eliminating undefined transitions.\n\nLiveness\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/live.png)\n\nTrap State\n----------\n\nIntroduce new state _qtrap_ or _qt_\n\n*   _δlive(m)_ =\n    \n        {0R0,0G1,\n         1G1,1Y2,\n         2Y2,2R0,\n         0Yt,1Rt,2Gt}\n    \n*   _Σ_ = {_R_, _G_, _Y_ }\n*   _Q_ = {_0_, _1_, _2_, _t_ }\n\nWe need a way to preserve existing state transitions, while eliminating undefined transitions.\n\nLiveness\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/trap.png)\n\nTrap State\n----------\n\nBut how does _Σ_ = {_R_, _G_, _Y_ } figure in?\n\n  \n\nA flashing red _F_ or out light _O_ can still be green in the future!\n\n  \n\nThe trap transition aren't fixed letters - they are the **the rest of the alphabet!**\n\n*   _δlive(m)_ =\n    \n        {0R0,0G1,\n         1G1,1Y2,\n         2Y2,2R0,\n         0*t,1*t,2*t}\n    \n*   _Σ_ = {_R_, _G_, _Y_, _F_, _O_, ... }\n\nLiveness\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/many.png)\n\nTrap State\n----------\n\n    \n\nTransition\n\nLetter\n\n_{R}_\n\n_{G}_\n\n_{Y}_\n\n_Σ_/{_R_, _G_, _Y_ }\n\nInitial State\n\nNext State\n\n**_q0_**\n\n_q0_\n\n_q1_\n\n_qt_\n\n_qt_\n\n_q1_\n\n_qt_\n\n_q1_\n\n_q2_\n\n_qt_\n\n_q2_\n\n_q0_\n\n_qt_\n\n_q2_\n\n_qt_\n\nLive()\n------\n\nWe recall the definition of safety.\n\n`Live(m)` requires the \"good thing\" for a Buchi automaton, which is entering an accepting state infinitely often, because we require this \"good thing\" to happen for trace to be accepted.\n\nSo in practice, we have\n\n`Live(m)` is `m` augmented by an accepting trap state _qt_ and new transition function _δlive(m)_ which is the transition function _δ_ extended so that it causes every undefined transition of `m` to put `Live(m)` in _qt_\n\nOverall\n-------\n\nMost Simple\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/live.png)\n\nMost Correct\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/many.png)\n\nWhy trap states\n---------------\n\nIn defense of the most correct version with trap.\n\n*   This trap state captures all safety failures.\n*   Anything going to trap is not in `Safe()`\n*   Likewise, anything in `Safe()` that is accepted, is \"green eventually\".\n\nThis gives \"safe and green or unsafe\".\n\nMost Correct\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/many.png)\n\nWhy trap states\n---------------\n\nThis gives \"safe and green or unsafe\".\n\n*   That is, it gives `m` and also something else - all unsafe traces.\n*   Recall: We use _Σ_ ω (upper case sigma raised to lower case omega) to denote infinite traces.\n*   So `Live(m)` = `m` **∪** _Σ ω_ / `Safe(m)`\n*   Say \"the liveness property is everything that is both safe and live, and everything that isn't safe.\"\n\nMost Correct\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/many.png)\n\nIntersection\n------------\n\nSafe()\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/safe.png)\n\n`cl(m)`\n\nLive()\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/many.png)\n\n`m` **∪** _Σω_ / `cl(m)`\n\nIntersection\n------------\n\nWe take the intersection of these two sets (of traces).\n\n*   `Live(m)`**∩**`Safe(m)`, that is\n    \n*   `cl(m)`**∩**`m`**∪**_Σω_/ `cl(m)`\n    \n\nWe consider:\n\n1.  Everything in `m` is in `cl(m)`, that is, `m`**⊂**`cl(m)`\n2.  Everything in `cl(m)` is in _Σω_, that is, `cl(m)`**⊂**_Σω_\n3.  Nothing in `m` is in _Σω_/ `cl(m)`, that is, `m`**∩**_Σω_/ `cl(m)`\\=_∅_\n\nLet's take a look.\n\nIntersection\n------------\n\n1.  Everything in `m` is in `cl(m)`, that is, `m`**⊂**`cl(m)`\n2.  Everything in `cl(m)` is in _Σω_, that is, `cl(m)`**⊂**_Σω_\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/m1.png)\n\nIntersection\n------------\n\n1.  Everything in `m` is in `cl(m)`, that is, `m`**⊂**`cl(m)`\n2.  Nothing in `m` is in _Σω_/ `cl(m)`, that is, `m`**∩**_Σω_/`cl(m)`\\=_∅_\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/m2.png)\n\nIntersection\n------------\n\n1.  Everything in `m` is in `cl(m)`\n2.  Everything in `m` is in `m`**∪**_Σω_/ `cl(m)`\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/m1.png)\n\nIntersection\n------------\n\nNothing in `cl(m)` is in `m`**∪**_Σω_/ `cl(m)` without being in `m`\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/m1.png)\n\nEverything in `m` is in `m`**∪**_Σω_/ `cl(m)` and in `cl(m)`\n\nIntersection\n------------\n\nSafe lights are yellow before red.\n\nLive lights are either (1) green someday, or (2) don't use yellow.\n\nSafe, live lights are (1) green someday, and (2) use yellow.\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/m3.png)\n\nWork time\n---------\n\nSafe()\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/safe.png)\n\n`cl(m)`\n\nLive()\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/many.png)\n\n`m` **∪** _Σω_ / `cl(m)`\n\n",
    "supporting": [
      "logics_files"
    ],
    "filters": [],
    "includes": {}
  }
}