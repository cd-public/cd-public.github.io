{
  "hash": "1bd2e4f06533bc893eed08b4a99396b5",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: SHA256\nauthor: Prof. Calvin\nsubtitle: \"Week 0x2\"\ninstitute: Crypto\nformat: \n    revealjs: \n        code-fold: false\n        theme: dark\n        mainfont: monospace\n        slide-number: true\n        show-slide-number: all\n        width: 1050\n        height: 700\n\nexecute:\n    echo: true\n    cache: true\n    freeze: true  # never re-render during project render\n---\n\n\n# Announcements\n\n- **Welcome** to variously CS 276/CS 540\n- **Action Items**:\n  - How was Macros?\n  - Next homework coming out now - SHAinC\n\n# Today\n\n- SHA256\n    -   Why?\n    -   What?\n    -   How?\n\n# Slide Credit\n\n-   [**Saravanan Vijayakumaran**](https://www.ee.iitb.ac.in/~sarva/)\n-   sarva@ee.iitb.ac.in  \n-   Department of Electrical Engineering  \n-   Indian Institute of Technology Bombay  \n\n# Hash Functions\n\n-   Methods for **deterministically** compress a long input string to a shorter output called a digest\n    -   Also called \"signature\"\n    -   Can hash *anything stored in computer*\n-   These are also called \"compression\" or \"one-way\" hash functions.\n\n# Hash Merits\n\n-   Primary requirement is that it should be infeasible to find collisions, \n    -   i.e. no two inputs have same digest.\n    -   If I download Ubuntu and check the signature, I should know it's Ubuntu.\n    -   If Ubuntu and a malware package have the same signature, useless.\n\n# Non-Cryptographic\n\n-   Used to build **<strong>**hash tables**</strong>** \n    -   Key-value stores with $\\mathcal{O}(1)$ lookup time. \n    -   [My hashtable/hashmap slides](https://cd-public.github.io/slide_portable/hashmap.html#/title-slide)\n-   Example: Python `hash`\n\n::: {#8798f571 .cell execution_count=2}\n``` {.python .cell-code}\nprint(\"\\n\".join([f\"{hash(a):+d}\" for a in \"ABCDE\"]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+1373127204756315779\n+8789652758067317931\n-2276255771787240274\n+5026827255279295070\n+2062924699377293058\n```\n:::\n:::\n\n\n# Example.tex\n\n-   Let $M$ be the size of some hash table\n-   Take $a, W \\in \\mathbb{N} : W < M \\land \\gcd(a, W) = 1$\n    -   That is, two positive coprime integers.\n-   Any integer value $x$ can be mapped into $\\mathbb{N}_M = \\{0,1,\\ldots, M-1\\}$\n    \n```LaTeX\nh_a(x) = \\left\\lfloor \\frac{a x \\bmod W}{W} M \\right\\rfloor\n```\n$$\nh_a(x) = \\left\\lfloor \\frac{a x \\bmod W}{W} M \\right\\rfloor\n$$\n\n# Example.py\n-   We can express in a programming language.\n-   We note that 257 == 0x101 is prime.\n    -   And therefore $\\forall W : gcd(257,W)$\n\n::: {#19af3640 .cell execution_count=3}\n``` {.python .cell-code}\nimport math\nh = lambda x, a, W, M : math.floor(((a * x) % W) / W * M)\na, W, M = 0x101, 1 << 0x10, 1 << 0x08\nassert(all((not math.gcd(a, W) == 1) or h(x, a, W, M) in range(M) for x in range(M)))\nprint('h'+str((0xDA7A,a,W,M)), '=', h(0xDA7A,a,W,M))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nh(55930, 257, 65536, 256) = 84\n```\n:::\n:::\n\n\n# Example.c\n-   We note a high performance special case.\n-   Let $w$ be the bit size used to store numbers\n    -   Likely 32 == 0x20 for C `unsigned`\n    -   $W$ stands for [word](https://en.wikipedia.org/wiki/Word_(computer_architecture)) size\n-   Take $W = 2^w$ and $M = 2^m$\n\n```{.C}\nunsigned int h(unsigned int x, unsigned int a, unsigned int m) {\n    return (a * x) >> (sizeof(unsigned int) * 0x10 - m); \n}\n```\n\n# Collisions\n\n-   A **collision** occurs if\n$$\n\\exists x, x' : x \\neq x` \\land h(x) = h(x')\n$$\n-   That is, this assertion *fails*:\n```{.py}\nassert(((x_0 != x_1) and (h(x_0, a, W, M) == h(x_1, a, W, M)))\n```\n-   **Goal:** minimize:non-crypto::avoid:crypto collisions.\n    -   Achieve this via a large co-domain for $h$\n\n# Codomain:\n\n> [\"In mathematics, a codomain or set of destination of a function is a set into which all of the output of the function is constrained to fall. It is the set $Y$ in the notation $f: X → Y$. The term range is sometimes ambiguously used to refer to either the codomain or the image of a function.\"](https://en.wikipedia.org/wiki/Codomain)\n\n# Test it:\n\n::: {#549599c3 .cell execution_count=4}\n``` {.python .cell-code}\nh = lambda x, a, W, M : math.floor(((a * x) % W) / W * M)\na, W, M = 0x101, 1 << 0x10, 1 << 0x08\nassert(set(h(x, a, W, M) for x in range(M)) == set(range(M)))\n```\n:::\n\n\n-   As a rule we shouldn't try to write proofs/definitions in Python, but...\n-   Small $W = 2^{0x10} = 65536$ means our computer can handle all possibilities.\n\n# Visualize:\n\n<img style=\"filter: invert(100%);\" src=\"https://www.ee.iitb.ac.in/~sarva/courses/EE720/2023/slides/images/codomain-256.svg\">\n\n# Cryptgraphic\n\n-   Begin with SHA-2 (Secure Hash Algorithm 2).\n    -   A family of cryptographic hash functions.\n    -   By the [U.S. National Security Agency (NSA)](https://www.youtube.com/watch?v=mJHvSp9AKYg)\n-   Published by the U.S. National Institute of Standards and Technology (NIST) in 2001.\n\n# Context\n-   SHA-1, released in 1995, found to have significant vulnerabilities.\n-   Growing concerns about the security of SHA-1 led to the development of SHA-2.\n    -   SHA-3 released in 2015, not in wide use.\n    -   For *if* weakness in SHA-2 discovered.\n    -   SHA-2 regarded as secure in 2025.\n\n# Family\n- Six hash functions release August 2001:\n  - SHA-224\n  - SHA-256\n  - SHA-384\n  - SHA-512\n  - SHA-512/224\n  - SHA-512/256\n\n# Adoption and Usage\n-   SHA-2 has been widely adopted in \n    -   Digital signatures\n    -   Certificate validation\n    -   File integrity verification.\n    -   **Blockchain:** \n        -   1 of ~2 core technologies of Bitcoin\n        -   SHA-256 specifically\n\n# SHA-2 Pledge\n\n-   I need a verbal confirmation:\n    -   Even though we will implement cryptography...\n    -   We assume their insecurity as we learn to:\n        -   Test our code\n        -   Write proofs\n        -   Use compilers\n    -   We don't know what side channel attacks are.\n        -   I say: out-of-scope.\n\n# SHA-256 Overview\n\n- **SHA-2** with a **256-bit output length**\n- Accepts bit strings of length up to $2^{64} - 1$\n    -   ~20 quintillion bits\n    -   ~17 million terabytes\n\n# Two Stages\n\n- Output calculation has two stages:\n  1. **Preprocessing**\n  2. **Hash Computation**\n\n# Preprocessing\n\n- A 256-bit state variable $H^{(0)}$ is initialized:\n\n\\begin{align*}\n\\begin{split}\n   H_0^{(0)} = \\texttt{0x6A09E667}, \\quad H_1^{(0)} = \\texttt{0xBB67AE85},\\\\\n   H_2^{(0)} = \\texttt{0x3C6EF372}, \\quad H_3^{(0)} = \\texttt{0xA54FF53A},\\\\\n   H_4^{(0)} = \\texttt{0x510E527F}, \\quad H_5^{(0)} = \\texttt{0x9B05688C},\\\\\n   H_6^{(0)} = \\texttt{0x1F83D9AB}, \\quad H_7^{(0)} = \\texttt{0x5BE0CD19}.\n\\end{split}\n   \\end{align*}\n\n- We'll calculate these in the lab.\n\n# Input Padding\n\n- The input $M$ is padded to a length that is a multiple of 512.\n\n- Let $M$ be $l$-bits long.\n- Find the smallest non-negative $k$ such that:\n$$\nk + l + 65 = 0 \\pmod{512}\n$$\n\n# Padding Content\n\n- Append $k + l + 65$ bits: \n    -   A single one (`1`), followed by \n    -   $k$ zeros (`0`), followed by\n    -   The 64-bit representation of $l$.\n$$\n\\begin{align*}\n1\\underbrace{000 \\cdots 000}_{n \\textrm{ zeros}}\\underbrace{l}_{\\textrm{ 64 bits}} \\\\\n\\end{align*}\n$$\n\n# Example.py\n\n-   We can solve numerical in Python, but...\n-   Perhaps easier to show with strings.\n\n::: {#127f2605 .cell execution_count=5}\n``` {.python .cell-code}\nk, l = 8, 123\nprint('String:', '0b1' + '0' * (k) + f\"{l:064b}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nString: 0b1000000000000000000000000000000000000000000000000000000000000000001111011\n```\n:::\n:::\n\n\n-   The arithmetic form is left an exercise for the interested student.\n    -   My solution was 10-20 characters of code.\n\n# Hash Computation\n\n- Padded input is split into $N$ 512-bit blocks: \n$$\nM^{(1)}, M^{(2)}, \\ldots, M^{(N)}\n$$\n- The hash function has the following type:\n$$\nf: M:\\{0,1\\}^{512} \\times H:\\{0,1\\}^{256} \\rightarrow H':\\{0,1\\}^{256}\n$$\n- Given $H(i-1)$, calculate $H(i)$ using:\n $$\n H(i) = f(M^{(i)}, H(i-1)), \\quad 1 \\leq i \\leq N.\n $$\n\n\n# Words\n\n-   We specify bitwise operations over **exactly** 32 bit words.\n-   The industry standard is to use `stdint`\n```{.C}\n#include <stdint.h>\n\n/* uint32_t is \"unsigned integer of size 32 type\" */\nuint32_t rotate(uint32_t a, uint32_t b) {\n    asm(\"rorl %%cl, %0\" : \"+r\" (a) : \"c\" (b));\n    return a;\n}\n```\n\n# Operations\n\n- Bitwise logical operations\n    -   Unary,\n    -   Binary, and\n    -   Ternary, and\n- Shift/rotate operations\n- Operations work over 1, 2, or 3 words of size 32 (uint32_t)\n    -   Term these words $U$, $V$, $W$\n\n# Unary Bitwise\n\n- The first is 'bitwise complement', or \n- 'bitwise logical not':\n$$\n\\lnot U\n$$\n- There is no graceful Python implementation.\n```{.C}\nuint32_t complement(uint32_t u) {\n    return ~u ;\n}\n```\n\n# Binary Bitwise\n\n- $U \\land V$, $U \\lor V$, $U \\oplus V$: AND, OR, XOR\n- $SHR_n(U)$: shift right by $n$\n- $ROTR_n(U)$: rotate right by $n$\n\n- **Special functions**:\n$$\n\\text{Ch}(U, V, W) = (U \\land V) \\oplus (\\lnot U \\land W)\n$$\n$$\n\\text{Maj}(U, V, W) = (U \\land V) \\oplus (U \\land W) \\oplus (V \\land W)\n$$\n$$\n\\Sigma_0(U) = ROTR_2(U) \\oplus ROTR_{13}(U) \\oplus ROTR_{22}(U)\n$$\n$$\n\\Sigma_1(U) = ROTR_6(U) \\oplus ROTR_{11}(U) \\oplus ROTR_{25}(U)\n$$\n\n\n\n## Compression Function Calculation\n\n1. **Internal State Initialization**:\n $$\n W_j = \n \\begin{cases} \n M^{(i)}_j & 0 \\leq j \\leq 15 \\\\\n \\sigma_1(W_{j-2}) + W_{j-7} + \\sigma_0(W_{j-15}) + W_{j-16} & 16 \\leq j \\leq 63\n \\end{cases}\n $$\n\n2. Initialize eight 32-bit words:\n $$\n (A, B, C, D, E, F, G, H) = (H(i-1)_0, \\ldots, H(i-1)_7).\n $$\n\n3. Iterate $j = 0$ to $63$:\n $$\n T_1 = H + \\Sigma_1(E) + \\text{Ch}(E, F, G) + K_j + W_j\n $$\n $$\n T_2 = \\Sigma_0(A) + \\text{Maj}(A, B, C)\n $$\n $$\n (A, B, C, D, E, F, G, H) = (T_1 + T_2, A, B, C, D + T_1, E, F, G)\n $$\n\n4. Update $H(i)$:\n $$\n H(i)_j = A + H(i-1)_j, \\quad j = 0, \\ldots, 7\n $$\n\n\n\n## The Merkle-Damgård Transform\n\n- **Construction**: Example of MD transform.\n- **Purpose**: Extend domain to construct collision-resistant hash functions.\n\n\n\n## References\n\n- Chapter 3 of *An Introduction to Bitcoin*, S. Vijayakumaran  \n[www.ee.iitb.ac.in/~sarva/bitcoin.html](https://www.ee.iitb.ac.in/~sarva/bitcoin.html)\n\n",
    "supporting": [
      "sha256_files"
    ],
    "filters": [],
    "includes": {}
  }
}