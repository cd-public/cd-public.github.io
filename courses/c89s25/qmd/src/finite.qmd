---
title: Finite
theme: dark
author: Prof. Calvin
subtitle: "Week 0x4"
institute: Crypto
format: 
    revealjs: 
        code-fold: true
        theme: dark
        mainfont: monospace
        slide-number: true
        show-slide-number: all
        width: 1050
        height: 700
        footer: "[Home](../index.html)"

execute:
    echo: false
---
# Announcements

- **Welcome** to variously CS 276/CS 540
  - This was called "BigNum"
  - Renamed after doing some theory work
- **Action Items**:
  - SHA-256 extended to two weeks.

# Apocryphal Quote

- I cannot find it, but I believe a philosopher one jested:

> I am a weapons-grade finitist. I don't believe in numbers larger than two.

- Arrays of such numbers are sufficient for computation of arbitrary precision.
- We can not capture the infinite, but we may model it.
  
# Today

- Reintroduce the technologies
  - `stdint`
- Some number theory
  - Finite sets, rings
  
# What are integers?

- Denote integers as the mathematical symbol $\mathbb{Z}$
  - Something to do with the German/Deutsch
- Not particular useful in cryptography, actually
  - We tend to want the naturals, denoted $\mathbb{N}$
  - Counting numbers, $0$ and up.

# In Python

- We can write them in Python with `itertools`

```{.python filename="fields.py"}
from itertools import count
N = count()
make_z = lambda n : n // 2 if n % 2 else -n // 2
Z = (make_z(n) for n in count(1))
# We can see elements of these infinite collections with
[next(N) for _ in range(5)], [next(Z) for _ in range(5)]
```

- What do you see?
```python
([0, 1, 2, 3, 4], [0, -1, 1, -2, 2])
```

# Aside

- It is moderately controversial to assert:
$$
0 \in \mathbb{N}
$$
  - Enderton, Herbert B. (1977). Elements of set theory. New York: Academic Press. p. 66. ISBN 0122384407.
- Fortunately this is a CS class.
```python
assert(0 in count())
```

# $\mathbb{N}$ is akin to `uint`

- The natural numbers $\mathbb{N}$ probably look a lot like the unsigned integers.
- There's only one real problem.
- We don't have the unsigned integers in C
  - We don't have them in Python either, but for a different reason.

# The Problem

- Python has been lying to us for years that its integer have no upper limit.
  - We say $\nexists n : n \notin$ `count()`
  - Let's just try a reasonably sized number, say googolplex $= 10^{10^{100}}$

# Test with `-c`

- We use the `-c` flag to Python to run a script directly at command line.
```python
python3 -c "print('hello world')"
```
- Perform multi-line calculuations using `;`
  - Oh - like C. ðŸ¤”

```python
python3 -c "from itertools import count; print(0 in count())"
```

# Time it

- Running on Linux 
   - `podman start -l ; podman exec -it -l`
- We can use `time` to... time things.
```email
$ time python3 -c "from itertools import count; print(0 in count())"
True
0.01user 0.00system 0:00.01elapsed 109%CPU (0avgtext+0avgdata 8748maxresident)k
0inputs+0outputs (0major+942minor)pagefaults 0swaps
```

# Pivot to bash

- Looks nicer in `/bin/bash`
```email
$ /bin/bash
user@DESKTOP-THMS2PJ:~/tmp$ time python3 -c "from itertools import count; print(0 in count())"
True

real    0m0.013s
user    0m0.014s
sys     0m0.000s
```

- We could argue it takes .013 seconds to check
- Or .013 seconds to find itertools on a SDD

# Bigger Numbers

- Check e.g. 1000
```email
$ /bin/bash
user@DESKTOP-THMS2PJ:~/tmp$ time python3 -c "from itertools import count; print(1000 in count())"
True

real    0m0.012s
user    0m0.012s
sys     0m0.000s
```

- Trivial.

# Test it

- Try a few powers yourself. What do you find?

```email
time python3 -c "from itertools import count; n=1; print(10**n in count())"
```

# 

::::{.columns}

:::{.column width="%50"}

|10^$n$|`real`|
|-|-|
|1|00.012|
|2|00.012|
|3|00.012|
|4|00.013|
|5|00.013|
|6|00.027|
|7|00.164|
|8|01.498|
|9|16.810|

:::


:::{.column width="%50"}

- Expect:
$$
t(10^{10}) \in [140,170]
$$
- Expect for $n \gt 9$
$$
t(10^n) \in [14,17] \times 10^{n-9}
$$
- Expect $10^{10^{100}}$ in
  - (Googol - 9) seconds
  - 316 novemvigintilion years

:::

::::

# C for Clear

- C is a little more forthright about how big its numbers get.
```{.C filename="max.c"}
#include <stdio.h>
#include <stdint.h>

int main() {
	uint32_t n = 0;
	while ((n + 1) > n) {
		n++;
	}
	printf("n = %u\n", n);
	return 0;
}
```

# C fast

- For me, this took 5.19s on `uint32_t`
  - Same value in Python was 1m9.32s
- How long for  `uint64_t`?
  - In Python?
- How would speed up the code?
  - What assumptions did you make?
- How many base 10 digits does the largest number we can store in 32 bytes have?

# limits.h 

- C discloses the maximum values it can tolerate in `<limits.h>`
```{.C filename="num.c"}
#include <stdio.h>
#include <limits.h>

int main() {
    printf("n = %u\n", UINT_MAX);
    return 0;
}
```
- The correct answer was binary search.
  - The incorrect answer (so far) was subtraction.

# Rings

- As far as I know (not a mathematician) the `uint`s and `int`s in C are *rings*
  - They have addition and multiplication
- They aren't fields - zero is divisible
  - Spoiler alert, but $2^{\frac{n}{2}} \times 2^{\frac{n}{2}} \equiv 0 \pmod{2^n}$

# Rings vs Integers

- Rings have some "goofy" features
  - $a, b \in$ `uint`$n$`_t` $\nRightarrow a + b > a$
  - Same with multiplication.
- Let's look at an example.

# Checkers

```{.C filename="num.c"}
#include <stdlib.h>
#include <stdint.h>

int main(int argc, char **argv) {
    uint8_t x, y;
    x = atoi(argv[1]);
    y = atoi(argv[2]);
    return x + y;
}
```

- `atoi` - alphabetical to int
- From `<stdlib.h>` per `man atoi`, but might work without that.

# Do some additions

```email
$  ./a.out 100 100 ; echo $?
200
$ ./a.out 200 100 ; echo $?
44
```
- 44? From whence?

# uint8_t is *finite*

```email
>>> 200 + 100
300
>>> 2 ** 8
256
>>> 300 - 256
44
>>> 300 % 256
44
```
- Operations on `uint8_t` values are equivalent to operations on the natural numbers modulo $2^8$
$$
\mathbb{N}_{2^8}
$$

# In practice

- $\exists$ `INT_MAX`, `UINT_MAX`, `CHAR_MAX`, etc.
  - They use C names, not `stdint` names
- Sums and products less than these values are unaffected
- Sums and products greater than these values are taken modulo said max.
- $\forall a, b \in$ `uint`$n$`_t` $: a + b \equiv a + b \pmod {2^n}$

# Problem Statement

- Quoth GitHub

> [`ssh-keygen -t rsa -b 4096 -C "your_email@example.com"`](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent)

- Wait a minute. 
- What does that 4096 stand for?
  - For what does that 4096 stand?

# 4096 bits

- Modern security recommendations are for 4096 bit cryptographic keys.
  - 2048 is generally considered "okay" or "acceptable"

```email
NAME
     ssh-keygen â€” OpenSSH authentication key utility

SYNOPSIS
     ssh-keygen [-q] [-a rounds] [-b bits] 
```

# Today

- Reintroduce the technologies
  - &check; `stdint`
- Some number theory
  - &check; Finite sets, rings
  